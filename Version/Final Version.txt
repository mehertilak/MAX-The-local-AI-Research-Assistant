Final Version 

Features 
1)Chat feature 
2)RAG feature
3)Image processor feature
4)Live chat feature
5)Web crawler feature
6)Voice chat feature  


Code for this version 


JavaScript

class ChatApp {
    constructor() {
        // State Management
        this.ragMode = false;
        this.voiceMode = false;
        this.darkMode = false;
        this.currentMode = 'chat';
        this.history = [];
        this.recordedChunks = [];
        this.timerInterval = null;
        this.tutorialSeen = localStorage.getItem('tutorialSeen') === 'true'; // Track if tutorial seen
        this.isRecording = false;
        this.uploadedImage = null; // Variable to store the uploaded image file

        // DOM Elements
        this.chatInput = document.getElementById('chatInput');
        this.chatMessages = document.getElementById('chatMessages');
        this.welcomeMessage = document.getElementById('welcomeMessage');
        this.tutorialOverlay = document.getElementById('tutorialOverlay'); // Tutorial overlay
        this.tutorialToggleButton = document.getElementById('tutorialToggleButton'); // Tutorial toggle button
        this.liveStatusCircle = document.getElementById('liveStatusCircle');
        this.micBtn = document.getElementById('micBtn'); // Mic button
        this.voiceCommOverlay = document.getElementById('voiceCommOverlay'); // Voice overlay

        // Initialize
        this.initializeEventListeners();
        this.initializeTheme();

        // Show tutorial if not seen before (initially disabled for toggle button implementation)
        // if (!this.tutorialSeen) {
        //     this.showTutorial();
        // }
    }

    // ========================
    // Core Initialization
    // ========================
    initializeEventListeners() {
        // Message Handling
        this.chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') this.handleSendMessage();
        });

        // File Handling
        document.getElementById('paperclipBtn').addEventListener('click', () => {
            this.currentMode = 'rag';
            document.getElementById('fileInput').click();
        });
        document.getElementById('fileInput').addEventListener('change', (e) => this.handleFileUpload(e));

        // Image Handling
        document.getElementById('cameraBtn').addEventListener('click', () => {
            this.currentMode = 'image_chat';
            document.getElementById('imageInput').click();
        });
        document.getElementById('imageInput').addEventListener('change', (e) => this.handleImageUpload(e));

        // Voice Chat
        this.micBtn.addEventListener('click', () => this.toggleVoiceChat());
        document.getElementById('voiceCommClose').addEventListener('click', () => this.stopVoiceChat());

        // Theme
        document.getElementById('themeSwitch').addEventListener('click', () => this.toggleTheme());

        // Tutorial Toggle Button
        this.tutorialToggleButton.addEventListener('click', () => this.toggleTutorial());


        // QR Scanner
        document.getElementById('scannerBtn').addEventListener('click', () => this.startQrScanner());
        document.getElementById('qrScannerClose').addEventListener('click', () => this.stopQrScanner());

        // Video Handling
        document.getElementById('videoBtn').addEventListener('click', () => {
             if(this.currentMode === 'rag'){
                this.cleanupRag();
             }
            if(this.currentMode === 'web_crawler'){
                this.cleanupWeb();
            }
             if(this.currentMode === 'image_chat'){
                this.cleanupImage();
            }
            this.currentMode = 'live_chat';
            document.getElementById('videoOptionsOverlay').style.display = 'flex';
        });

        document.getElementById('startLiveVideoBtn').addEventListener('click', async () => {
            document.getElementById('liveRecorderOverlay').style.display = 'flex';
            // Call the new startLiveVideo function
            await this.startLiveVideo();
        });

        document.getElementById('videoOptionsClose').addEventListener('click', () => {
            document.getElementById('videoOptionsOverlay').style.display = 'none';
        });

        document.getElementById('liveRecorderClose').addEventListener('click', async () => {
            document.getElementById('liveRecorderOverlay').style.display = 'none';
             // Call the new stopLiveVideo function
            await this.stopLiveVideo();
             if(this.currentMode === 'rag'){
                this.cleanupRag();
            }
            if(this.currentMode === 'web_crawler'){
                this.cleanupWeb();
            }
            if(this.currentMode === 'image_chat'){
                this.cleanupImage();
            }
             this.currentMode = 'chat';
        });

        // Status Circle
        this.liveStatusCircle.addEventListener('click', () => this.toggleLiveStatus());

        // Tutorial Close Button
        document.getElementById('tutorialClose').addEventListener('click', () => this.hideTutorial());

        // Removed event listener for videoInput change
        // document.getElementById('videoInput').addEventListener('change', (e) => this.handleVideoUpload(e));
    }

    // ========================
    // Image Handling
    // ========================
   async handleImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        // Step 1: Show preview immediately
        const imageUrl = URL.createObjectURL(file);
        this.addMessage('user', `<img src="${imageUrl}" class="image-preview">`);


         this.showTypingIndicator();
        const formData = new FormData();
         formData.append('image', file);

         try {
             const response = await fetch('/upload_image', {
                method: 'POST',
                 body: formData
            });

             if (response.ok) {
                 const data = await response.json();
                if(data.success){
                     this.addMessage('ai', data.response);
                    this.addMessage('ai', `Image Caption: ${data.caption}`);
                     this.currentMode = 'image_chat';
                    this.uploadedImage = file; // Store the uploaded image file
                 }
                else{
                     this.addMessage('ai', `Image processing failed: ${data.error}`);
                 }

             }
             else{
                const errorData = await response.json()
                 this.addMessage('ai', `Image processing failed: ${errorData.error}`);
             }

         } catch (error) {
             this.addMessage('ai', 'Image processing failed');
         } finally {
             this.hideTypingIndicator();
             event.target.value = '';
        }
    }


    // ========================
    // API Communication
    // ========================
    async postData(url, data) {
        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });
          if (!response.ok) {
              const errorData = await response.json()
              throw new Error(errorData.error);
          }
           return await response.json();
        }
        catch (error) {
            console.error('API Error:', error);
             this.addMessage('ai', `Error: ${error.message}`);
            return null;
        }
    }

    // ========================
    // Message Handling
    // ========================
    async handleSendMessage() {
        const message = this.chatInput.value.trim();
        if (!message) return;


        this.addMessage('user', message);
        this.chatInput.value = '';
        this.welcomeMessage.classList.add('fade-out');
        this.showTypingIndicator();
        try {
            let response;
            if(this.currentMode === 'chat'){
                response = await this.postData('/chat', {
                    message: message
                });
                if (response?.response) {
                    this.addMessage('ai', response.response);
                }
            }
            else if (this.currentMode === 'rag'){
                if(message.toLowerCase() === 'exit'){
                    this.cleanupRag();
                    this.addMessage('ai', `Exiting RAG mode.`);
                    this.currentMode = 'chat'
                    return;
                }
                response = await this.postData('/rag_query', {
                    question: message
                });
                if (response?.response) {
                    this.addMessage('ai', response.response, response.document_name);
                }
            }
            else if (this.currentMode === 'web_crawler'){
                 if(message.toLowerCase() === 'exit'){
                    this.cleanupWeb();
                    this.addMessage('ai', `Exiting Web Crawler mode.`);
                    this.currentMode = 'chat'
                    return;
                }
                response = await this.postData('/web_query', {
                    question: message
                });
                 if (response?.response) {
                    this.addMessage('ai', response.response, response.document_name);
                 }
            }
            else if (this.currentMode === 'image_chat'){
                 if(message.toLowerCase() === 'exit'){
                     this.cleanupImage();
                     this.addMessage('ai', `Exiting Image Chat mode.`);
                      this.currentMode = 'chat'
                     return;
                 }

                 let response;
                 const formData = new FormData(); // Always create FormData in image_chat mode
                 formData.append('question', message);


                 try{
                     const response = await fetch('/image_query', {
                         method: 'POST',
                         body: formData, // Send FormData with just question now
                         // Content-Type is AUTOMATICALLY set by fetch for FormData
                     });
                     if (response.ok) {
                         const data = await response.json();
                         if(data.success){
                             if (data.image_path) {
                                  // Step 2: Display detected/pointed images
                                this.addMessage('ai', `<img src="${data.image_path}" class="image-preview">`);
                             }
                             else{
                                 this.addMessage('ai', data.response)
                             }
                         }
                         else{
                             this.addMessage('ai', `Image processing failed: ${data.error}`);
                         }
                     }
                     else{
                         const errorData = await response.json()
                         this.addMessage('ai', `Image processing failed: ${errorData.error}`);
                     }
                 }
                 catch (error) {
                     this.addMessage('ai', `Error: ${error.message}`);
                 }
            }
        }
        finally {
            this.hideTypingIndicator();
        }
    }

    // ========================
    // File Handling
    // ========================
    async handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const formData = new FormData();
        formData.append('file', file);

        this.showTypingIndicator();

        try {
            const response = await fetch('/upload', {
                method: 'POST',
                body: formData
            });

            if (response.ok) {
                const data = await response.json();
                if(data.success){
                   this.ragMode = true;
                  this.addMessage('ai', `I understand the details in the document, lets talk about it`);
                }
                else{
                   const errorData = await response.json()
                   this.addMessage('ai', `File Upload Failed: ${errorData.error}`);
                }
            }
             else{
                   const errorData = await response.json()
                   this.addMessage('ai', `File Upload Failed: ${errorData.error}`);
              }
        }
        catch (error) {
            this.addMessage('ai', 'File upload failed');
        }
        finally {
            this.hideTypingIndicator();
            event.target.value = '';
              if(this.currentMode === 'image_chat'){
                this.cleanupImage();
            }
        }
    }


    // ========================
    // Video Handling
    // ========================
   async startLiveVideo() {
        try {
            const response = await this.postData('/start_live_chat', {});
            if (!response || !response.success) {
                this.addMessage('ai', 'Failed to start live chat.');
                return;
            }

            // Add Loading indication as the camera stream is not available.
            document.getElementById('liveVideoPreview').style.display = 'none'; // Hide preview
            document.getElementById('loadingIndicator').style.display = 'block'; // Show loading

            this.liveStatusCircle.classList.add('active');
            this.isRecording = true;

        } catch (error) {
            console.error('Video error:', error);
            this.addMessage('ai', 'Failed to start live chat.');
        }
    }

    async stopLiveVideo() {
        try {
            const response = await this.postData('/stop_live_chat', {});
            if (!response || !response.success) {
                this.addMessage('ai', 'Failed to stop live chat.');
                return;
            }
             document.getElementById('liveVideoPreview').style.display = 'block'; // Show preview
             document.getElementById('loadingIndicator').style.display = 'none'; // Hide loading
            this.liveStatusCircle.classList.remove('active');
            this.isRecording = false;
        } catch (error) {
            console.error('Video error:', error);
            this.addMessage('ai', 'Failed to stop live chat.');
        }
    }

    // ========================
    // Live Status Circle
    // ========================
    toggleLiveStatus(){
        if(this.isRecording){
            this.liveStatusCircle.classList.remove('active');
            this.stopLiveVideo()
        }
        else{
           this.liveStatusCircle.classList.add('active');
           this.startLiveVideo()
        }
    }
    // ========================
    // Voice Chat System
    // ========================
    async toggleVoiceChat() {
        if (this.voiceMode) {
            // Stop voice chat
            this.voiceMode = false;
            this.voiceCommOverlay.style.display = 'none';
            this.micBtn.classList.remove('active'); // Deactivate the mic button

            try {
                const response = await this.postData('/stop_voice_chat', {});
                if (!response?.success) {
                    this.addMessage('ai', 'Failed to stop voice chat.');
                }
            } catch (error) {
                console.error("Error stopping voice chat:", error);
                this.addMessage('ai', 'Failed to stop voice chat.');
            }
        } else {
            // Start voice chat
            this.voiceMode = true;
            this.voiceCommOverlay.style.display = 'flex';
            this.micBtn.classList.add('active'); // Activate the mic button

            try {
                const response = await this.postData('/start_voice_chat', {});
                if (!response?.success) {
                    this.addMessage('ai', 'Failed to start voice chat.');
                    this.voiceMode = false; // Reset state
                    this.voiceCommOverlay.style.display = 'none'; // Hide the overlay if start fails
                    this.micBtn.classList.remove('active'); //Deactivate the mic button
                }
            } catch (error) {
                console.error("Error starting voice chat:", error);
                this.addMessage('ai', 'Failed to start voice chat.');
                this.voiceMode = false; // Reset state
                this.voiceCommOverlay.style.display = 'none'; // Hide the overlay if start fails
                this.micBtn.classList.remove('active'); //Deactivate the mic button
            }
        }
    }

    stopVoiceChat() {
         this.voiceMode = false;
        this.voiceCommOverlay.style.display = 'none';
        this.micBtn.classList.remove('active'); // Deactivate the mic button

         this.postData('/stop_voice_chat', {})
    }

    // ========================
    // RAG Mode Cleanup
    // ========================
     async cleanupRag(){
            try {
                await this.postData('/cleanup_rag',{});
                this.ragMode = false
            } catch (error) {
                console.error('RAG cleanup failed',error)
            }
     }

    // ========================
    // Web Crawler Mode Cleanup
    // ========================
     async cleanupWeb(){
         try {
            await this.postData('/cleanup_web',{});
            this.currentMode = 'chat';
        } catch (error) {
            console.error('Web crawler cleanup failed',error)
        }
    }
    // ========================
    // Image Chat Mode Cleanup
    // ========================
    async cleanupImage(){
         try {
             await this.postData('/cleanup_image',{});
             this.currentMode = 'chat';
         } catch (error) {
             console.error('Image chat cleanup failed',error)
         }
     }
    // ========================
    // QR Scanner
    // ========================
        startQrScanner() {
        document.getElementById('qrScannerOverlay').style.display = 'flex';
        this.html5QrCode = new Html5Qrcode('qr-scanner-view');
        
          let scanningActive = true; // New flag to prevent multiple triggers

        this.html5QrCode.start({
                facingMode: 'environment'
            }, {
                fps: 10,
                qrbox: 250
            },
            async (decodedText) => { // Use arrow function here
                 if (!scanningActive) return;
                 scanningActive = false; // Prevent further triggers

                document.getElementById('qrResultDisplay').textContent = decodedText;


                  // Check if the decoded text is a URL
                 if (this.isValidUrl(decodedText)) {
                       this.stopQrScanner();  // Close the popup immediately after URL detection
                    if(this.currentMode === 'web_crawler'){
                        await this.cleanupWeb();
                    }
                    if(this.currentMode === 'image_chat'){
                        await this.cleanupImage();
                    }
                     this.currentMode = 'web_crawler';

                      this.showTypingIndicator()
                    try {
                          const response = await this.postData('/crawl_website', {
                             url: decodedText
                            });
                         if(response){
                            this.addMessage('ai', `I saw through the veils of the Internet, Now I know it's secrets. Let's talk about it`);
                         }
                    } catch (error) {
                        this.addMessage('ai', `Web crawling failed ${error}`)
                    }
                    finally{
                        this.hideTypingIndicator()
                        
                    }


                 } else {
                     document.getElementById('qrResultDisplay').textContent = "Not a valid URL";
                      setTimeout(() => {
                            this.stopQrScanner()
                        }, 1000)
                 }

            },
             errorMessage => console.warn(errorMessage)
         );
     }

    stopQrScanner() {
        document.getElementById('qrScannerOverlay').style.display = 'none';
        if (this.html5QrCode) {
            this.html5QrCode.stop().then(()=>{
                 this.html5QrCode = null; // Clean up instance
            })
        }

    }
     isValidUrl(string) {
        try {
          new URL(string);
          return true;
        } catch (_) {
          return false;
        }
      }

    // ========================
    // UI Components
    // ========================
    addMessage(sender, message, sourceDoc = null) {
        const bubble = document.createElement('div');
        bubble.className = `message-bubble ${sender}`;
        bubble.innerHTML = sourceDoc ?
            `${message} <br> <span class="source-doc">Source: ${sourceDoc}</span>` :
            message;

        this.chatMessages.appendChild(bubble);
        this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
    }

    showTypingIndicator() {
        const typing = document.createElement('div');
        typing.className = 'typing-indicator';
        for (let i = 0; i < 3; i++) {
            typing.appendChild(document.createElement('div')).className = 'typing-dot';
        }
        this.chatMessages.appendChild(typing);
    }

    hideTypingIndicator() {
        document.querySelector('.typing-indicator')?.remove();
    }

    // ========================
    // Theme Management
    // ========================
    initializeTheme() {
        this.darkMode = localStorage.getItem('theme') === 'dark';
        document.body.classList.toggle('dark-mode', this.darkMode);
        document.querySelector('.theme-switch-icon').textContent = this.darkMode ? '🌙' : '🔅';
        localStorage.setItem('theme', this.darkMode ? 'dark' : 'light');
    }

    toggleTheme() {
        this.darkMode = !this.darkMode;
        document.body.classList.toggle('dark-mode');
        document.querySelector('.theme-switch-icon').textContent = this.darkMode ? '🌙' : '🔅';
        localStorage.setItem('theme', this.darkMode ? 'dark' : 'light');
    }


    // ========================
    // Tutorial Management
    // ========================
    showTutorial() {
        this.tutorialOverlay.classList.add('active');
    }

    hideTutorial() {
        this.tutorialOverlay.classList.remove('active');
        localStorage.setItem('tutorialSeen', 'true'); // Mark tutorial as seen
    }

    toggleTutorial() {
        if (this.tutorialOverlay.classList.contains('active')) {
            this.hideTutorial();
        } else {
            this.showTutorial();
        }
    }
}

// Initialize Application
document.addEventListener('DOMContentLoaded', () => {
    window.chatApp = new ChatApp();
});


________________________________________________________________________________________________________________________________________________________________________

app.py

import logging
import os
from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
from modules.chat_module import ChatHandler, conversational_prompt
from modules.rag_model import DocumentRAG, upload_file, process_rag_query
from modules.web_crawler import EphemeralRAG
from modules import image_scanner
from tempfile import TemporaryDirectory
import asyncio
from PIL import Image
import uuid  # Import uuid for unique filenames

# MODIFIED IMPORTS
import subprocess
import signal
import threading

# Import live_video.py as a module (No longer needed here)
# from modules import live_video # Removed unnecessary import

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

app = Flask(__name__, static_folder='../frontend')
CORS(app)  # Enable CORS for all routes

# Initialize the chat handler
chat_handler = ChatHandler()

# Initialize the RAG model
rag_model = DocumentRAG()

# Initialize the Web Crawler
web_crawler = None

# Initialize mode tracker
current_mode = 'chat'

# NEW GLOBAL VARIABLES FOR LIVE CHAT
live_video_process = None
live_video_lock = threading.Lock()

# NEW GLOBAL VARIABLES FOR VOICE CHAT
voice_chat_process = None
voice_chat_lock = threading.Lock()

# Serve Frontend
@app.route('/')
def serve_frontend():
    return send_from_directory(app.static_folder, 'index.html')

@app.route('/<path:path>')
def serve_static(path):
    if os.path.isfile(os.path.join(app.static_folder, path)):
        return send_from_directory(app.static_folder, path)
    else:
        return send_from_directory(app.static_folder, 'index.html')

# Add this new route to serve detected images
@app.route('/detected_images/<filename>')
def serve_detected_image(filename):
    return send_from_directory(image_scanner.output_folder, filename)

@app.route('/chat', methods=['POST'])
def handle_chat():
    """Handles general chat requests."""
    global current_mode
    try:
        data = request.get_json()
        if not data or 'message' not in data:
            logging.warning("Invalid request: No message received")
            return jsonify({"error": "Invalid request: No message provided"}), 400

        user_message = data['message']
        response = chat_handler.handle_conversation(conversational_prompt, user_message)

        if response is None:
             logging.error("Chat response generation failed")
             return jsonify({"error": "Failed to generate a response"}), 500
        return jsonify({"response": response, "success":True})

    except Exception as e:
        logging.error(f"Unexpected error during chat handling: {e}")
        return jsonify({"error": f"An unexpected error occurred: {e}", "success":False}), 500

@app.route('/upload', methods=['POST'])
def handle_upload():
    """Handles file uploads for RAG."""
    global current_mode
    try:
        if 'file' not in request.files:
             logging.warning("Invalid request: No file received")
             return jsonify({"error": "No file part", "success":False}), 400

        file = request.files['file']

        if file.filename == '':
           logging.warning("Invalid request: No file selected")
           return jsonify({'error': 'No selected file', "success":False}), 400

        # Create a TemporaryDirectory instance
        temp_dir = TemporaryDirectory()
        upload_folder = temp_dir.name if not rag_model.persist_data else "data/uploads"
        file_path, filename = upload_file(file, upload_folder)

        if not file_path:
            temp_dir.cleanup()
            return jsonify({"error": "File saving failed", "success":False}), 500

        content = rag_model.load_document(file_path)

        if not content:
            temp_dir.cleanup()
            return jsonify({"error": "Document loading failed", "success":False}), 500

        documents = rag_model.process_content(content, filename)

        if not documents:
             temp_dir.cleanup()
             return jsonify({"error": "Document processing failed", "success":False}), 500

        rag_model.create_vector_store(documents)
        temp_dir.cleanup()
        return jsonify({'filename': filename, "success":True}), 200

    except Exception as e:
         logging.error(f"Error during file upload: {e}")
         return jsonify({"error": f"An unexpected error occurred: {e}", "success":False}), 500

@app.route('/rag_query', methods=['POST'])
def handle_rag_query():
    """Handles RAG queries."""
    try:
        data = request.get_json()
        if not data or 'question' not in data:
            logging.warning("Invalid request: No question received")
            return jsonify({"error": "Invalid request: No question provided", "success":False}), 400

        question = data['question']
        response = process_rag_query(question, rag_model)

        if response is None:
            logging.error("Error getting the answer from RAG model")
            return jsonify({"error": "Failed to generate a response", "success":False}), 500

        return jsonify({'response':response['result'], 'document_name': response['source_documents'][0].metadata['source'], "success":True}), 200

    except Exception as e:
         logging.error(f"Error during rag query: {e}")
         return jsonify({"error": f"An unexpected error occurred: {e}", "success":False}), 500

@app.route('/cleanup_rag', methods=['POST'])
def handle_cleanup_rag():
    """Handles the cleanup of the rag model."""
    try:
        rag_model.cleanup()
        return jsonify({'message': 'RAG mode cleanup successfully', "success":True}), 200
    except Exception as e:
         logging.error(f"Error during rag cleanup: {e}")
         return jsonify({"error": f"An unexpected error occurred: {e}", "success":False}), 500

@app.route('/crawl_website', methods=['POST'])
async def handle_crawl_website():
    """Handles website crawling requests."""
    global current_mode
    global web_crawler
    try:
         data = request.get_json()
         if not data or 'url' not in data:
            logging.warning("Invalid request: No URL received")
            return jsonify({"error": "Invalid request: No URL provided", "success":False}), 400

         url = data['url']
         if web_crawler:
             web_crawler.cleanup()
         web_crawler = EphemeralRAG()

         content = await web_crawler.crawl_website(url)

         if not content:
            return jsonify({"error": "Website crawling failed", "success":False}), 500

         documents = web_crawler.process_content(content, url)
         web_crawler.create_vector_store(documents)

         return jsonify({'message': 'Website crawled successfully', "success":True}), 200

    except Exception as e:
         logging.error(f"Error during web crawling: {e}")
         return jsonify({"error": f"An unexpected error occurred: {e}", "success":False}), 500

@app.route('/web_query', methods=['POST'])
def handle_web_query():
    """Handles web crawl queries."""
    try:
        data = request.get_json()
        if not data or 'question' not in data:
            logging.warning("Invalid request: No question received")
            return jsonify({"error": "Invalid request: No question provided", "success":False}), 400

        question = data['question']
        if web_crawler is None:
            logging.error("Web Crawler is None")
            return jsonify({"error": "Web Crawler not initialized", "success":False}), 500

        response = web_crawler.setup_qa_chain().invoke({"query":question})

        if response is None:
            logging.error("Error getting the answer from Web Crawler model")
            return jsonify({"error": "Failed to generate a response", "success":False}), 500

        return jsonify({'response':response['result'], 'document_name': response['source_documents'][0].metadata['source'], "success":True}), 200

    except Exception as e:
         logging.error(f"Error during web query: {e}")
         return jsonify({"error": f"An unexpected error occurred: {e}", "success":False}), 500

@app.route('/cleanup_web', methods=['POST'])
def handle_cleanup_web():
    """Handles the cleanup of the web crawler."""
    try:
         if web_crawler:
             web_crawler.cleanup()
         return jsonify({'message': 'Web crawler mode cleanup successfully', "success":True}), 200
    except Exception as e:
         logging.error(f"Error during web cleanup: {e}")
         return jsonify({"error": f"An unexpected error occurred: {e}", "success":False}), 500

@app.route('/upload_image', methods=['POST'])
def handle_upload_image():
     """Handles image uploads for image processing."""
     global current_mode
     try:
          if 'image' not in request.files:
               logging.warning("Invalid request: No image received")
               return jsonify({"error": "No image part", "success":False}), 400
          image_file = request.files['image']
          if image_file.filename == '':
               logging.warning("Invalid request: No image selected")
               return jsonify({'error': 'No selected image', "success":False}), 400

          # Create temporary directory
          temp_dir = TemporaryDirectory()
          # Generate a unique filename
          filename = os.path.join(temp_dir.name, f"{uuid.uuid4()}{os.path.splitext(image_file.filename)[1]}")
          # Save the uploaded image to the temporary directory
          image_file.save(filename)

          # Process with saved file path
          with Image.open(filename) as image: # Open image using the saved path
              caption_result = image_scanner.get_image_caption(image, filename) # Pass image and server-side file path

          # Store temporary directory for cleanup - pass temp_dir to image_scanner
          image_scanner.set_temp_dir(temp_dir) # Pass temp_dir instance for cleanup

          if not caption_result['success']:
               logging.error(f"Error during image caption: {caption_result['error']}")
               return jsonify({'error': 'Error generating image caption', "success":False}), 500

          current_mode = 'image_chat'
          return jsonify({'response': "I am looking at the image you sent me . I have to say it is looking interesting" , 'caption': caption_result['response'], "success":True}), 200

     except Exception as e:
          logging.error(f"Error during image upload: {e}")
          return jsonify({"error": f"An unexpected error occurred: {e}", "success":False}), 500

@app.route('/image_query', methods=['POST'])
def handle_image_query():
     """Handles image processing queries."""
     try:
          # Directly get question from request.form - expecting FormData
          question = request.form.get('question')
          if not question:
               logging.warning("Invalid request: No question received in FormData")
               return jsonify({"error": "Invalid request: No question provided", "success":False}), 400

          if "detect" in question.lower():
            object_to_detect = question.split("detect")[1].strip()
            detection_result = image_scanner.detect_objects(object_to_detect)
            if not detection_result["success"]:
                logging.error(f"Error during object detection: {detection_result['error']}")
                return jsonify({"error": detection_result['response'], "success": False})
            return jsonify(detection_result)

          elif "point" in question.lower():
            query = question.split("point")[1].strip()
            point_result = image_scanner.point_at_object(query)
            if not point_result["success"]:
                logging.error(f"Error during object pointing: {point_result['error']}")
                return jsonify({"error": point_result['response'], "success": False})
            return jsonify(point_result)

          else:
             answer_result = image_scanner.answer_image_question(question)
             if not answer_result["success"]:
                logging.error(f"Error during image question answering: {answer_result['error']}")
                return jsonify({"error": answer_result["error"], "success":False}), 500
             return jsonify(answer_result)

     except Exception as e:
          logging.error(f"Error during image processing: {e}")
          return jsonify({"error": f"An unexpected error occurred: {e}", "success":False}), 500

@app.route('/cleanup_image', methods=['POST'])
def handle_cleanup_image():
    """Handles the cleanup of the image resources."""
    global current_mode
    try:
        cleanup_result = image_scanner.cleanup_image_resources()
        if not cleanup_result["success"]:
            logging.error(f"Error during image cleanup: {cleanup_result['error']}")
            return jsonify({"error": "Error during image cleanup", "success":False}), 500
        current_mode = 'chat'
        return jsonify(cleanup_result), 200
    except Exception as e:
         logging.error(f"Error during image cleanup: {e}")
         return jsonify({"error": f"An unexpected error occurred: {e}", "success":False}), 500

# NEW LIVE CHAT ENDPOINTS
@app.route('/start_live_chat', methods=['POST'])
def start_live_chat():
    """Starts the live chat process."""
    global live_video_process
    global voice_chat_process

    with live_video_lock:  # Use live_video_lock for live video
        if live_video_process is not None:
            logging.warning("Live chat already running")
            return jsonify({'error': 'Live chat already running', "success":False}), 400

        if voice_chat_process is not None:
            with voice_chat_lock: # Use voice_chat_lock before accessing voice_chat_process
                try:
                     os.kill(voice_chat_process.pid, signal.SIGTERM)
                     voice_chat_process.wait()
                     voice_chat_process = None
                     logging.info("Voice chat stopped successfully")
                except Exception as e:
                     logging.error(f"Failed to stop voice chat: {e}")

        try:
            live_video_process = subprocess.Popen(['python', 'modules/live_video.py'])
            logging.info("Live chat started successfully")
            return jsonify({'message': 'Live chat started', "success":True}), 200
        except Exception as e:
            logging.error(f"Failed to start live chat: {e}")
            return jsonify({'error': f'Failed to start live chat: {e}', "success":False}), 500

@app.route('/stop_live_chat', methods=['POST'])
def stop_live_chat():
    """Stops the live chat process."""
    global live_video_process

    with live_video_lock: # Use live_video_lock for live video
        if live_video_process is None:
            logging.warning("Live chat is not running")
            return jsonify({'error': 'Live chat not running', "success":False}), 400

        try:
            os.kill(live_video_process.pid, signal.SIGTERM)
            live_video_process.wait()
            live_video_process = None
            logging.info("Live chat stopped successfully")
            return jsonify({'message': 'Live chat stopped', "success":True}), 200
        except Exception as e:
             logging.error(f"Failed to stop live chat: {e}")
             return jsonify({'error': f'Failed to stop live chat: {e}', "success":False}), 500

# NEW VOICE CHAT ENDPOINTS
@app.route('/start_voice_chat', methods=['POST'])
def start_voice_chat():
    """Starts the voice chat process."""
    global voice_chat_process
    global live_video_process

    with voice_chat_lock:  # Use voice_chat_lock for voice chat
        if voice_chat_process is not None:
            logging.warning("Voice chat already running")
            return jsonify({'error': 'Voice chat already running', "success": False}), 400

        if live_video_process is not None:
             with live_video_lock: # Use live_video_lock before accessing live_video_process
                try:
                     os.kill(live_video_process.pid, signal.SIGTERM)
                     live_video_process.wait()
                     live_video_process = None
                     logging.info("Live video stopped successfully")
                except Exception as e:
                     logging.error(f"Failed to stop live video: {e}")

        try:
            voice_chat_process = subprocess.Popen(['python', 'modules/voice_chat.py'])
            logging.info("Voice chat started successfully")
            return jsonify({'message': 'Voice chat started', "success": True}), 200
        except Exception as e:
            logging.error(f"Failed to start voice chat: {e}")
            return jsonify({'error': f'Failed to start voice chat: {e}', "success": False}), 500

@app.route('/stop_voice_chat', methods=['POST'])
def stop_voice_chat():
    """Stops the voice chat process."""
    global voice_chat_process

    with voice_chat_lock: # Use voice_chat_lock for voice chat
        if voice_chat_process is None:
            logging.warning("Voice chat is not running")
            return jsonify({'error': 'Voice chat not running', "success": False}), 400

        try:
            os.kill(voice_chat_process.pid, signal.SIGTERM)
            voice_chat_process.wait()
            voice_chat_process = None
            logging.info("Voice chat stopped successfully")
            return jsonify({'message': 'Voice chat stopped', "success": True}), 200
        except Exception as e:
            logging.error(f"Failed to stop voice chat: {e}")
            return jsonify({'error': f'Failed to stop voice chat: {e}', "success": False}), 500

if __name__ == '__main__':
    app.run(debug=True, port=5000)


____________________________________________________________________________________________________________________________________________________________


